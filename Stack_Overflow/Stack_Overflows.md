# Stack Overflows


## Basics:


Most stack based overflows are possible due to surpassing the allocated length for an array, overwriting anything below it, in the stack. Depending on the compiler used, the array may be padded with extra space, for the data structure alignment. Also, variable order may be changed in the compiled code, due to compiler optimizations.

A basic example of variable overflow is in *sample0.c* code. We compile the source code with:

	gcc sample0.c -o sample0.out -m32 -fno-stack-protector
    
Giving input over 32 characters, in my environment conditions, we overflow *var1*.

A point of interest in exploiting the stack is the **return address**, that is the saved **EIP** register. It is usually located after the *saved stack frame*. Overwriting it with an invalid address causes the program to crash. Using a valid address, we get control to the execution flow.
	
An execution flow control can be proven using *sample0.c*, jumping *target()*. We first disable address randomization, so we can call a static addresses.
	`gcc sample0.c -o sample0.out -m32 -fno-stack-protector  -no-pie`
	
For the sake of the example we need to find the amount of data we need to overwrite to actually change the saved instruction pointer and the address we want to jump to.
	
To get the address of the function *target()* we can use gdb:
	`gdb sample0.out`
	`(gdb) i functions`
	
In my case, the function is located at *0x080484cb*.

In order to find how much data we need to pass to the program, there are 2 main methods:

The first involves in reading trough all the code, calculating the offset between the return address and the location of the array. 

The second method consists of giving the program predictable characters position and crashing it with a segmentation fault. The address of which the segmentation fault points us to will be in our predictable string, thus getting the offset.

We can see the the information we need in gdb.

Also, note that the argument variable for the function is popped off the stack. It is located with an offset of 4 after the targeted jump address.

Exploiting the program:

	python -c 'print "A"*32+ "CCCADDDBEEEEFFFF" + "\x86\x84\x04\x08" + "AAAA" +"\xde\xc0\xad\xde"' | ./sample0.out




We can also execute arbitrary code, in the right circumstances. It depends on the executable tag of code sections and the location in which we can write to the memory. We also should keep in mind the format of the code before it is actually executed. For example, 0x00 means a NULL terminator to the `gets()` function.
	Shellcode is the term used to refer to position independent code that is injected into a program, that usually spawns a shell.

We can get a shell spawned in the program. We must first instruct the compiler to not use *Data Execution Prevention* optimization so we can execute code located in the stack.

	gcc sample0.c -o sample0.out -m32 -fno-stack-protector  -no-pie -z execstack

The technique is explored in the Shellcode section of BasicExploits.

