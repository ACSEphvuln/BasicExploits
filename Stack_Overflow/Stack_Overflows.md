# Stack Overflows


## Basics:


Most stack based overflows are possible due to surpassing the allocated length for an array, overwriting anything below it, in the stack. Depending on the compiler used, the array may be padded with extra space, for the data structure alignment. Also, variable order may be changed in the compiled code, due to compiler optimizations.

A basic example of variable overflow is in *sample0.c* code. We compile the source code with:

	gcc sample0.c -o sample0.out -m32 -fno-stack-protector
    
Giving input over 32 characters, in my environment conditions, we overflow *var1*.

+ A point of interest in exploiting the stack is the **return address**, that is the saved **EIP** register. It is usually located after the *saved stack frame*. Overwriting it with an invalid address causes the program to crash. Using a valid address, we get control to the execution flow.
	
	An execution flow control can be proven using *sample0.c*, jumping *target()*. We first disable address randomization, so we can call a static addresses all over the program. This will helpful for next sections.`sudo bash -c "echo 0 > /proc/sys/kernel/randomize_va_space"`
    
    Compile the first sample with:
        
		`gcc sample0.c -o sample0.out -m32 -fno-stack-protector  -no-pie`
	
	For the sake of the example we need to find the amount of data we need to overwrite to actually change the saved instruction pointer and the address we want to jump to.
	
	To get the address of the function *target1()* we can use gdb:
	
    `gdb sample0.out` 
    
	`(gdb) i functions`
	
	In my case, the function *target1()* is located at *0x080484cb*.

In order to find how much data we need to pass to the program, in order to reach the return address there are 2 main methods:

- The first involves in reading trough all the code, calculating the offset between the return address and the location of the array. 

- The second method consists of giving the program predictable characters position and crashing it with a segmentation fault. The address of which the segmentation fault points us to will be in our predictable string, thus getting the offset.

We can see the the information we need in gdb. My offset after the string will be 4 bytes, the ladder being the saved *EBP*.

+ Before our address gets to be "returned" to, the function stack frame is destroyed and *EBP* restored ( with an overwritten value ). What remains in the stack is everything after ( and including ) the overwritten saved pointer. Knowing this, we can make function calls with arguments. Note that the arguments for functions is popped off the stack. Our is located with an offset of 4 bytes after the targeted jump address.

	Exploiting the program:

		python -c 'print "A"*32+ "DCBA" + "A"*12 + "\x86\x84\x04\x08" + "XXXX" +"\xff\xef\xcd\xab"' | ./sample0.out


	When calling multiple functions you should keep in mind that calling functions ( also some function instructions ) use the stack for operations. If you desire to call multiple functions, the safe way is to return to the vulnerable part of the code again ( or an address that eventually leads to the vulnerable code ) and repeat the process of overflowing to call the next function and so on.
	
	Since the newly "called" ( returned to ) function expects to return to an address itself, after it finishes the instructions. The expected return address that *target1()* will "return" to, will be in the place of *XXXX* located in our string. Since we have only 2 functions we want to call, each possessing only one argument we can do it directly:
    
		python -c 'print "A"*32+ "DCBA" + "A"*12 +  + "\x86\x84\x04\x08" + "\xcb\x84\x04\x08" +"\xff\xef\xcd\xab" + "\xde\xc0\xad\xde" ' | ./sample0.out 

	The general way to call multiple functions is at follows: returning to the vulnerable function so that it will be possible to exploit the function once again. Note that we must first terminate the string with a carriage return *"\x0a"*, after each use.

		python -c 'print "A"*32+ "DCBA" + "A"*12 + "\x86\x84\x04\x08" + "\x10\x85\x04\x08" +"\xff\xef\xcd\xab" + "\x0a" + print "A"*32+ "DCBA" + "A"*12 + "\xcb\x84\x04\x08" + "XXXX" +"\xde\xc0\xad\xde" ' | ./sample0.out
	
	
We can use code parts to run some existing code in the program using gadgets ( small pieces of code that after some operations use a *ret* instruction), thus exploiting return-oriented-programming.

+ We can also execute arbitrary code, in the right circumstances. It depends on the executable tag of code sections and the location in which we can write to the memory. We also should keep in mind the format of the code before it is actually executed. For example, 0x00 means a NULL terminator to the `gets()` function.
	Shellcode is the term used to refer to position independent code that is injected into a program, that usually spawns a shell.
    
We can get a shell spawned in the program. We must first instruct the compiler to not use *Data Execution Prevention* optimization so we can execute code located in the stack.

		gcc sample0.c -o sample0.out -m32 -fno-stack-protector  -no-pie -z execstack

The technique is explored in the Shellcode section of BasicExploits.

